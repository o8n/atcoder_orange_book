この問題は、それぞれが特定の範囲をカバーするゲートを通して全てのゲートが通過可能なIDカードの番号を探すものです。各ゲートは特定のIDカード番号の範囲しか許可しないため、全てのゲートが許可する範囲を求める必要があります。

この問題を解決するためには、すべてのゲートが許可する範囲を求めることが必要です。これは、すべてのゲートの最小の最大許可IDと最大の最小許可IDを求めることで可能です。これにより、全てのゲートが許可するIDの範囲を得ることができます。

```cpp
#include <iostream>
#include <algorithm>
using namespace std;

int main() {
    int N, M;
    cin >> N >> M;

    int left = 1, right = N;
    for (int i = 0; i < M; ++i) {
        int L, R;
        cin >> L >> R;
        left = max(left, L);
        right = min(right, R);
    }

    cout << max(0, right - left + 1) << endl;

    return 0;
}
```

このコードでは、初めに許可されるIDの範囲を全範囲（1からN）に設定しています。
その後、各ゲートについて、そのゲートが許可する範囲で全体の許可範囲を更新しています。

具体的には、全体の許可範囲の最小値（left）をゲートの許可範囲の最小値と全体の許可範囲の最小値の大きい方に、全体の許可範囲の最大値（right）をゲートの許可範囲の最大値と全体の許可範囲の最大値の小さい方に更新しています。

最後に、全体の許可範囲の最大値と最小値から許可されるIDの数を計算しています。許可範囲が存在しない場合（leftがrightより大きい場合）、max関数を用いて0を出力しています。

この解法の時間複雑性はO(M)で、Mはゲートの数を表します。これは、各ゲートについて一度だけ許可範囲の更新を行うからです。